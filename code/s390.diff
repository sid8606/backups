diff --git a/src/hotspot/cpu/s390/register_s390.cpp b/src/hotspot/cpu/s390/register_s390.cpp
index 71320bc1eed..02fd3b6c5e1 100644
--- a/src/hotspot/cpu/s390/register_s390.cpp
+++ b/src/hotspot/cpu/s390/register_s390.cpp
@@ -26,13 +26,6 @@
 #include "precompiled.hpp"
 #include "register_s390.hpp"
 
-
-const int ConcreteRegisterImpl::max_gpr = Register::number_of_registers * 2;
-const int ConcreteRegisterImpl::max_fpr = ConcreteRegisterImpl::max_gpr +
-                                          FloatRegister::number_of_registers * 2;
-const int ConcreteRegisterImpl::max_vr = ConcreteRegisterImpl::max_fpr +
-                                         VectorRegister::number_of_registers;
-
 const char* Register::name() const {
   const char* names[number_of_registers] = {
     "Z_R0",  "Z_R1",  "Z_R2",  "Z_R3",  "Z_R4",  "Z_R5",  "Z_R6",  "Z_R7",
diff --git a/src/hotspot/cpu/s390/register_s390.hpp b/src/hotspot/cpu/s390/register_s390.hpp
index c73300a4405..5dc8365bd36 100644
--- a/src/hotspot/cpu/s390/register_s390.hpp
+++ b/src/hotspot/cpu/s390/register_s390.hpp
@@ -64,6 +64,7 @@ class Register {
 public:
   enum {
     number_of_registers     = 16,
+    max_slots_per_register  = 2,
     number_of_arg_registers = 5
   };
 
@@ -170,6 +171,7 @@ class FloatRegister {
 public:
   enum {
     number_of_registers     = 16,
+    max_slots_per_register  = 2,
     number_of_arg_registers = 4
   };
 
@@ -285,6 +287,7 @@ class VectorRegister {
 public:
   enum {
     number_of_registers     = 32,
+    max_slots_per_register  = 4,
     number_of_arg_registers = 0
   };
 
@@ -379,23 +382,21 @@ constexpr VectorRegister Z_V31 = as_VectorRegister(31);
 
 // Need to know the total number of registers of all sorts for SharedInfo.
 // Define a class that exports it.
-
 class ConcreteRegisterImpl : public AbstractRegisterImpl {
  public:
   enum {
-    number_of_registers =
-      (Register::number_of_registers +
-      FloatRegister::number_of_registers)
-      * 2 // register halves
-      + VectorRegister::number_of_registers
-      + 1 // condition code register
+    max_gpr = Register::number_of_registers * Register::max_slots_per_register,
+    max_fpr = max_gpr + FloatRegister::number_of_registers * FloatRegister::max_slots_per_register,
+    max_vr  = max_fpr + VectorRegister::number_of_registers * VectorRegister::max_slots_per_register,
+
+    // A big enough number for C2: all the registers plus flags
+    // This number must be large enough to cover REG_COUNT (defined by c2) registers.
+    // There is no requirement that any ordering here matches any ordering c2 gives
+    // it's optoregs.
+    number_of_registers = max_vr + 1 // gpr/fpr/vr + flags
   };
-  static const int max_gpr;
-  static const int max_fpr;
-  static const int max_vr;
 };
 
-
 // Common register declarations used in assembler code.
 constexpr Register       Z_EXC_OOP = Z_R2;
 constexpr Register       Z_EXC_PC  = Z_R3;
diff --git a/src/hotspot/cpu/s390/s390.ad b/src/hotspot/cpu/s390/s390.ad
index f910ecc658b..cd14c8f129d 100644
--- a/src/hotspot/cpu/s390/s390.ad
+++ b/src/hotspot/cpu/s390/s390.ad
@@ -182,6 +182,165 @@ register %{
   reg_def Z_F15  (SOC, SOE, Op_RegF, 15, Z_F15->as_VMReg());
   reg_def Z_F15_H(SOC, SOE, Op_RegF, 99, Z_F15->as_VMReg()->next());
 
+  reg_def Z_VR0   ( SOC, SOC, Op_RegF, 0, VMRegImpl::Bad()  );
+  reg_def Z_VR0_H ( SOC, SOC, Op_RegF, 0, VMRegImpl::Bad()  );
+  reg_def Z_VR0_J ( SOC, SOC, Op_RegF, 0, VMRegImpl::Bad()  );
+  reg_def Z_VR0_K ( SOC, SOC, Op_RegF, 0, VMRegImpl::Bad()  );
+
+  reg_def Z_VR1   ( SOC, SOC, Op_RegF, 1, VMRegImpl::Bad()  );
+  reg_def Z_VR1_H ( SOC, SOC, Op_RegF, 1, VMRegImpl::Bad()  );
+  reg_def Z_VR1_J ( SOC, SOC, Op_RegF, 1, VMRegImpl::Bad()  );
+  reg_def Z_VR1_K ( SOC, SOC, Op_RegF, 1, VMRegImpl::Bad()  );
+
+  reg_def Z_VR2   ( SOC, SOC, Op_RegF, 2, VMRegImpl::Bad()  );
+  reg_def Z_VR2_H ( SOC, SOC, Op_RegF, 2, VMRegImpl::Bad()  );
+  reg_def Z_VR2_J ( SOC, SOC, Op_RegF, 2, VMRegImpl::Bad()  );
+  reg_def Z_VR2_K ( SOC, SOC, Op_RegF, 2, VMRegImpl::Bad()  );
+
+  reg_def Z_VR3   ( SOC, SOC, Op_RegF, 3, VMRegImpl::Bad()  );
+  reg_def Z_VR3_H ( SOC, SOC, Op_RegF, 3, VMRegImpl::Bad()  );
+  reg_def Z_VR3_J ( SOC, SOC, Op_RegF, 3, VMRegImpl::Bad()  );
+  reg_def Z_VR3_K ( SOC, SOC, Op_RegF, 3, VMRegImpl::Bad()  );
+
+  reg_def Z_VR4   ( SOC, SOC, Op_RegF, 4, VMRegImpl::Bad()  );
+  reg_def Z_VR4_H ( SOC, SOC, Op_RegF, 4, VMRegImpl::Bad()  );
+  reg_def Z_VR4_J ( SOC, SOC, Op_RegF, 4, VMRegImpl::Bad()  );
+  reg_def Z_VR4_K ( SOC, SOC, Op_RegF, 4, VMRegImpl::Bad()  );
+
+  reg_def Z_VR5   ( SOC, SOC, Op_RegF, 5, VMRegImpl::Bad()  );
+  reg_def Z_VR5_H ( SOC, SOC, Op_RegF, 5, VMRegImpl::Bad()  );
+  reg_def Z_VR5_J ( SOC, SOC, Op_RegF, 5, VMRegImpl::Bad()  );
+  reg_def Z_VR5_K ( SOC, SOC, Op_RegF, 5, VMRegImpl::Bad()  );
+
+  reg_def Z_VR6   ( SOC, SOC, Op_RegF, 6, VMRegImpl::Bad()  );
+  reg_def Z_VR6_H ( SOC, SOC, Op_RegF, 6, VMRegImpl::Bad()  );
+  reg_def Z_VR6_J ( SOC, SOC, Op_RegF, 6, VMRegImpl::Bad()  );
+  reg_def Z_VR6_K ( SOC, SOC, Op_RegF, 6, VMRegImpl::Bad()  );
+
+  reg_def Z_VR7   ( SOC, SOC, Op_RegF, 7, VMRegImpl::Bad()  );
+  reg_def Z_VR7_H ( SOC, SOC, Op_RegF, 7, VMRegImpl::Bad()  );
+  reg_def Z_VR7_J ( SOC, SOC, Op_RegF, 7, VMRegImpl::Bad()  );
+  reg_def Z_VR7_K ( SOC, SOC, Op_RegF, 7, VMRegImpl::Bad()  );
+
+  reg_def Z_VR8   ( SOC, SOC, Op_RegF, 8, VMRegImpl::Bad()  );
+  reg_def Z_VR8_H ( SOC, SOC, Op_RegF, 8, VMRegImpl::Bad()  );
+  reg_def Z_VR8_J ( SOC, SOC, Op_RegF, 8, VMRegImpl::Bad()  );
+  reg_def Z_VR8_K ( SOC, SOC, Op_RegF, 8, VMRegImpl::Bad()  );
+
+  reg_def Z_VR9   ( SOC, SOC, Op_RegF, 9, VMRegImpl::Bad()  );
+  reg_def Z_VR9_H ( SOC, SOC, Op_RegF, 9, VMRegImpl::Bad()  );
+  reg_def Z_VR9_J ( SOC, SOC, Op_RegF, 9, VMRegImpl::Bad()  );
+  reg_def Z_VR9_K ( SOC, SOC, Op_RegF, 9, VMRegImpl::Bad()  );
+
+  reg_def Z_VR10   ( SOC, SOC, Op_RegF, 10, VMRegImpl::Bad()  );
+  reg_def Z_VR10_H ( SOC, SOC, Op_RegF, 10, VMRegImpl::Bad()  );
+  reg_def Z_VR10_J ( SOC, SOC, Op_RegF, 10, VMRegImpl::Bad()  );
+  reg_def Z_VR10_K ( SOC, SOC, Op_RegF, 10, VMRegImpl::Bad()  );
+
+  reg_def Z_VR11   ( SOC, SOC, Op_RegF, 11, VMRegImpl::Bad()  );
+  reg_def Z_VR11_H ( SOC, SOC, Op_RegF, 11, VMRegImpl::Bad()  );
+  reg_def Z_VR11_J ( SOC, SOC, Op_RegF, 11, VMRegImpl::Bad()  );
+  reg_def Z_VR11_K ( SOC, SOC, Op_RegF, 11, VMRegImpl::Bad()  );
+
+  reg_def Z_VR12   ( SOC, SOC, Op_RegF, 12, VMRegImpl::Bad()  );
+  reg_def Z_VR12_H ( SOC, SOC, Op_RegF, 12, VMRegImpl::Bad()  );
+  reg_def Z_VR12_J ( SOC, SOC, Op_RegF, 12, VMRegImpl::Bad()  );
+  reg_def Z_VR12_K ( SOC, SOC, Op_RegF, 12, VMRegImpl::Bad()  );
+
+  reg_def Z_VR13   ( SOC, SOC, Op_RegF, 13, VMRegImpl::Bad()  );
+  reg_def Z_VR13_H ( SOC, SOC, Op_RegF, 13, VMRegImpl::Bad()  );
+  reg_def Z_VR13_J ( SOC, SOC, Op_RegF, 13, VMRegImpl::Bad()  );
+  reg_def Z_VR13_K ( SOC, SOC, Op_RegF, 13, VMRegImpl::Bad()  );
+
+  reg_def Z_VR14   ( SOC, SOC, Op_RegF, 14, VMRegImpl::Bad()  );
+  reg_def Z_VR14_H ( SOC, SOC, Op_RegF, 14, VMRegImpl::Bad()  );
+  reg_def Z_VR14_J ( SOC, SOC, Op_RegF, 14, VMRegImpl::Bad()  );
+  reg_def Z_VR14_K ( SOC, SOC, Op_RegF, 14, VMRegImpl::Bad()  );
+
+  reg_def Z_VR15   ( SOC, SOC, Op_RegF, 15, VMRegImpl::Bad()  );
+  reg_def Z_VR15_H ( SOC, SOC, Op_RegF, 15, VMRegImpl::Bad()  );
+  reg_def Z_VR15_J ( SOC, SOC, Op_RegF, 15, VMRegImpl::Bad()  );
+  reg_def Z_VR15_K ( SOC, SOC, Op_RegF, 15, VMRegImpl::Bad()  );
+
+  reg_def Z_VR16   ( SOC, SOC, Op_RegF, 16, Z_V16->as_VMReg()          );
+  reg_def Z_VR16_H ( SOC, SOC, Op_RegF, 16, Z_V16->as_VMReg()->next()  );
+  reg_def Z_VR16_J ( SOC, SOC, Op_RegF, 16, Z_V16->as_VMReg()->next(2) );
+  reg_def Z_VR16_K ( SOC, SOC, Op_RegF, 16, Z_V16->as_VMReg()->next(3) );
+
+  reg_def Z_VR17   ( SOC, SOC, Op_RegF, 17, Z_V17->as_VMReg()          );
+  reg_def Z_VR17_H ( SOC, SOC, Op_RegF, 17, Z_V17->as_VMReg()->next()  );
+  reg_def Z_VR17_J ( SOC, SOC, Op_RegF, 17, Z_V17->as_VMReg()->next(2) );
+  reg_def Z_VR17_K ( SOC, SOC, Op_RegF, 17, Z_V17->as_VMReg()->next(3) );
+
+  reg_def Z_VR18   ( SOC, SOC, Op_RegF, 18, Z_V18->as_VMReg()          );
+  reg_def Z_VR18_H ( SOC, SOC, Op_RegF, 18, Z_V18->as_VMReg()->next()  );
+  reg_def Z_VR18_J ( SOC, SOC, Op_RegF, 18, Z_V18->as_VMReg()->next(2) );
+  reg_def Z_VR18_K ( SOC, SOC, Op_RegF, 18, Z_V18->as_VMReg()->next(3) );
+
+  reg_def Z_VR19   ( SOC, SOC, Op_RegF, 19, Z_V19->as_VMReg()          );
+  reg_def Z_VR19_H ( SOC, SOC, Op_RegF, 19, Z_V19->as_VMReg()->next()  );
+  reg_def Z_VR19_J ( SOC, SOC, Op_RegF, 19, Z_V19->as_VMReg()->next(2) );
+  reg_def Z_VR19_K ( SOC, SOC, Op_RegF, 19, Z_V19->as_VMReg()->next(3) );
+
+  reg_def Z_VR20   ( SOC, SOC, Op_RegF, 20, Z_V20->as_VMReg()          );
+  reg_def Z_VR20_H ( SOC, SOC, Op_RegF, 20, Z_V20->as_VMReg()->next()  );
+  reg_def Z_VR20_J ( SOC, SOC, Op_RegF, 20, Z_V20->as_VMReg()->next(2) );
+  reg_def Z_VR20_K ( SOC, SOC, Op_RegF, 20, Z_V20->as_VMReg()->next(3) );
+
+  reg_def Z_VR21   ( SOC, SOC, Op_RegF, 21, Z_V21->as_VMReg()          );
+  reg_def Z_VR21_H ( SOC, SOC, Op_RegF, 21, Z_V21->as_VMReg()->next()  );
+  reg_def Z_VR21_J ( SOC, SOC, Op_RegF, 21, Z_V21->as_VMReg()->next(2) );
+  reg_def Z_VR21_K ( SOC, SOC, Op_RegF, 21, Z_V21->as_VMReg()->next(3) );
+
+  reg_def Z_VR22   ( SOC, SOC, Op_RegF, 22, Z_V22->as_VMReg()          );
+  reg_def Z_VR22_H ( SOC, SOC, Op_RegF, 22, Z_V22->as_VMReg()->next()  );
+  reg_def Z_VR22_J ( SOC, SOC, Op_RegF, 22, Z_V22->as_VMReg()->next(2) );
+  reg_def Z_VR22_K ( SOC, SOC, Op_RegF, 22, Z_V22->as_VMReg()->next(3) );
+
+  reg_def Z_VR23   ( SOC, SOC, Op_RegF, 23, Z_V23->as_VMReg()          );
+  reg_def Z_VR23_H ( SOC, SOC, Op_RegF, 23, Z_V23->as_VMReg()->next()  );
+  reg_def Z_VR23_J ( SOC, SOC, Op_RegF, 23, Z_V23->as_VMReg()->next(2) );
+  reg_def Z_VR23_K ( SOC, SOC, Op_RegF, 23, Z_V23->as_VMReg()->next(3) );
+
+  reg_def Z_VR24   ( SOC, SOC, Op_RegF, 24, Z_V24->as_VMReg()          );
+  reg_def Z_VR24_H ( SOC, SOC, Op_RegF, 24, Z_V24->as_VMReg()->next()  );
+  reg_def Z_VR24_J ( SOC, SOC, Op_RegF, 24, Z_V24->as_VMReg()->next(2) );
+  reg_def Z_VR24_K ( SOC, SOC, Op_RegF, 24, Z_V24->as_VMReg()->next(3) );
+
+  reg_def Z_VR25   ( SOC, SOC, Op_RegF, 25, Z_V25->as_VMReg()          );
+  reg_def Z_VR25_H ( SOC, SOC, Op_RegF, 25, Z_V25->as_VMReg()->next()  );
+  reg_def Z_VR25_J ( SOC, SOC, Op_RegF, 25, Z_V25->as_VMReg()->next(2) );
+  reg_def Z_VR25_K ( SOC, SOC, Op_RegF, 25, Z_V25->as_VMReg()->next(3) );
+
+  reg_def Z_VR26   ( SOC, SOC, Op_RegF, 26, Z_V26->as_VMReg()          );
+  reg_def Z_VR26_H ( SOC, SOC, Op_RegF, 26, Z_V26->as_VMReg()->next()  );
+  reg_def Z_VR26_J ( SOC, SOC, Op_RegF, 26, Z_V26->as_VMReg()->next(2) );
+  reg_def Z_VR26_K ( SOC, SOC, Op_RegF, 26, Z_V26->as_VMReg()->next(3) );
+
+  reg_def Z_VR27   ( SOC, SOC, Op_RegF, 27, Z_V27->as_VMReg()          );
+  reg_def Z_VR27_H ( SOC, SOC, Op_RegF, 27, Z_V27->as_VMReg()->next()  );
+  reg_def Z_VR27_J ( SOC, SOC, Op_RegF, 27, Z_V27->as_VMReg()->next(2) );
+  reg_def Z_VR27_K ( SOC, SOC, Op_RegF, 27, Z_V27->as_VMReg()->next(3) );
+
+  reg_def Z_VR28   ( SOC, SOC, Op_RegF, 28, Z_V28->as_VMReg()          );
+  reg_def Z_VR28_H ( SOC, SOC, Op_RegF, 28, Z_V28->as_VMReg()->next()  );
+  reg_def Z_VR28_J ( SOC, SOC, Op_RegF, 28, Z_V28->as_VMReg()->next(2) );
+  reg_def Z_VR28_K ( SOC, SOC, Op_RegF, 28, Z_V28->as_VMReg()->next(3) );
+
+  reg_def Z_VR29   ( SOC, SOC, Op_RegF, 29, Z_V29->as_VMReg()          );
+  reg_def Z_VR29_H ( SOC, SOC, Op_RegF, 29, Z_V29->as_VMReg()->next()  );
+  reg_def Z_VR29_J ( SOC, SOC, Op_RegF, 29, Z_V29->as_VMReg()->next(2) );
+  reg_def Z_VR29_K ( SOC, SOC, Op_RegF, 29, Z_V29->as_VMReg()->next(3) );
+
+  reg_def Z_VR30   ( SOC, SOC, Op_RegF, 30, Z_V30->as_VMReg()          );
+  reg_def Z_VR30_H ( SOC, SOC, Op_RegF, 30, Z_V30->as_VMReg()->next()  );
+  reg_def Z_VR30_J ( SOC, SOC, Op_RegF, 30, Z_V30->as_VMReg()->next(2) );
+  reg_def Z_VR30_K ( SOC, SOC, Op_RegF, 30, Z_V30->as_VMReg()->next(3) );
+
+  reg_def Z_VR31   ( SOC, SOC, Op_RegF, 31, Z_V31->as_VMReg()          );
+  reg_def Z_VR31_H ( SOC, SOC, Op_RegF, 31, Z_V31->as_VMReg()->next()  );
+  reg_def Z_VR31_J ( SOC, SOC, Op_RegF, 31, Z_V31->as_VMReg()->next(2) );
+  reg_def Z_VR31_K ( SOC, SOC, Op_RegF, 31, Z_V31->as_VMReg()->next(3) );
 
   // Special Registers
 
@@ -194,38 +353,6 @@ register %{
 
   reg_def Z_CR(SOC, SOC, Op_RegFlags, 0, Z_CR->as_VMReg());   // volatile
 
-  reg_def Z_V0 ( SOC, SOC, Op_VecX, 0, VMRegImpl::Bad());
-  reg_def Z_V1 ( SOC, SOC, Op_VecX, 1, VMRegImpl::Bad());
-  reg_def Z_V2 ( SOC, SOC, Op_VecX, 2, VMRegImpl::Bad());
-  reg_def Z_V3 ( SOC, SOC, Op_VecX, 3, VMRegImpl::Bad());
-  reg_def Z_V4 ( SOC, SOC, Op_VecX, 4, VMRegImpl::Bad());
-  reg_def Z_V5 ( SOC, SOC, Op_VecX, 5, VMRegImpl::Bad());
-  reg_def Z_V6 ( SOC, SOC, Op_VecX, 6, VMRegImpl::Bad());
-  reg_def Z_V7 ( SOC, SOC, Op_VecX, 7, VMRegImpl::Bad());
-  reg_def Z_V8 ( SOC, SOC, Op_VecX, 8, VMRegImpl::Bad());
-  reg_def Z_V9 ( SOC, SOC, Op_VecX, 9, VMRegImpl::Bad());
-  reg_def Z_V10 ( SOC, SOC, Op_VecX, 10, VMRegImpl::Bad());
-  reg_def Z_V11 ( SOC, SOC, Op_VecX, 11, VMRegImpl::Bad());
-  reg_def Z_V12 ( SOC, SOC, Op_VecX, 12, VMRegImpl::Bad());
-  reg_def Z_V13 ( SOC, SOC, Op_VecX, 13, VMRegImpl::Bad());
-  reg_def Z_V14 ( SOC, SOC, Op_VecX, 14, VMRegImpl::Bad());
-  reg_def Z_V15 ( SOC, SOC, Op_VecX, 15, VMRegImpl::Bad());
-  reg_def Z_V16 ( SOC, SOC, Op_VecX, 16, Z_V16->as_VMReg());
-  reg_def Z_V17 ( SOC, SOC, Op_VecX, 17, Z_V17->as_VMReg());
-  reg_def Z_V18 ( SOC, SOC, Op_VecX, 18, Z_V18->as_VMReg());
-  reg_def Z_V19 ( SOC, SOC, Op_VecX, 19, Z_V19->as_VMReg());
-  reg_def Z_V20 ( SOC, SOC, Op_VecX, 20, Z_V20->as_VMReg());
-  reg_def Z_V21 ( SOC, SOC, Op_VecX, 21, Z_V21->as_VMReg());
-  reg_def Z_V22 ( SOC, SOC, Op_VecX, 22, Z_V22->as_VMReg());
-  reg_def Z_V23 ( SOC, SOC, Op_VecX, 23, Z_V23->as_VMReg());
-  reg_def Z_V24 ( SOC, SOC, Op_VecX, 24, Z_V24->as_VMReg());
-  reg_def Z_V25 ( SOC, SOC, Op_VecX, 25, Z_V25->as_VMReg());
-  reg_def Z_V26 ( SOC, SOC, Op_VecX, 26, Z_V26->as_VMReg());
-  reg_def Z_V27 ( SOC, SOC, Op_VecX, 27, Z_V27->as_VMReg());
-  reg_def Z_V28 ( SOC, SOC, Op_VecX, 28, Z_V28->as_VMReg());
-  reg_def Z_V29 ( SOC, SOC, Op_VecX, 29, Z_V29->as_VMReg());
-  reg_def Z_V30 ( SOC, SOC, Op_VecX, 30, Z_V30->as_VMReg());
-  reg_def Z_V31 ( SOC, SOC, Op_VecX, 31, Z_V31->as_VMReg());
 
 
 // Specify priority of register selection within phases of register
@@ -301,42 +428,42 @@ alloc_class chunk1(
 );
 
 alloc_class chunk2(
-  Z_CR
+ Z_VR0, Z_VR0_H, Z_VR0_J, Z_VR0_K,
+ Z_VR1, Z_VR1_H, Z_VR1_J, Z_VR1_K,
+ Z_VR2, Z_VR2_H, Z_VR2_J, Z_VR2_K,
+ Z_VR3, Z_VR3_H, Z_VR3_J, Z_VR3_K,
+ Z_VR4, Z_VR4_H, Z_VR4_J, Z_VR4_K,
+ Z_VR5, Z_VR5_H, Z_VR5_J, Z_VR5_K,
+ Z_VR6, Z_VR6_H, Z_VR6_J, Z_VR6_K,
+ Z_VR7, Z_VR7_H, Z_VR7_J, Z_VR7_K,
+ Z_VR8, Z_VR8_H, Z_VR8_J, Z_VR8_K,
+ Z_VR9, Z_VR9_H, Z_VR9_J, Z_VR9_K,
+ Z_VR10, Z_VR10_H, Z_VR10_J, Z_VR10_K,
+ Z_VR11, Z_VR11_H, Z_VR11_J, Z_VR11_K,
+ Z_VR12, Z_VR12_H, Z_VR12_J, Z_VR12_K,
+ Z_VR13, Z_VR13_H, Z_VR13_J, Z_VR13_K,
+ Z_VR14, Z_VR14_H, Z_VR14_J, Z_VR14_K,
+ Z_VR15, Z_VR15_H, Z_VR15_J, Z_VR15_K,
+ Z_VR16, Z_VR16_H, Z_VR16_J, Z_VR16_K,
+ Z_VR17, Z_VR17_H, Z_VR17_J, Z_VR17_K,
+ Z_VR18, Z_VR18_H, Z_VR18_J, Z_VR18_K,
+ Z_VR19, Z_VR19_H, Z_VR19_J, Z_VR19_K,
+ Z_VR20, Z_VR20_H, Z_VR20_J, Z_VR20_K,
+ Z_VR21, Z_VR21_H, Z_VR21_J, Z_VR21_K,
+ Z_VR22, Z_VR22_H, Z_VR22_J, Z_VR22_K,
+ Z_VR23, Z_VR23_H, Z_VR23_J, Z_VR23_K,
+ Z_VR24, Z_VR24_H, Z_VR24_J, Z_VR24_K,
+ Z_VR25, Z_VR25_H, Z_VR25_J, Z_VR25_K,
+ Z_VR26, Z_VR26_H, Z_VR26_J, Z_VR26_K,
+ Z_VR27, Z_VR27_H, Z_VR27_J, Z_VR27_K,
+ Z_VR28, Z_VR28_H, Z_VR28_J, Z_VR28_K,
+ Z_VR29, Z_VR29_H, Z_VR29_J, Z_VR29_K,
+ Z_VR30, Z_VR30_H, Z_VR30_J, Z_VR30_K,
+ Z_VR31, Z_VR31_H, Z_VR31_J, Z_VR31_K,
 );
 
 alloc_class chunk3(
- Z_V0,
- Z_V1,
- Z_V2,
- Z_V3,
- Z_V4,
- Z_V5,
- Z_V6,
- Z_V7,
- Z_V8,
- Z_V9,
- Z_V10,
- Z_V11,
- Z_V12,
- Z_V13,
- Z_V14,
- Z_V15,
- Z_V16,
- Z_V17,
- Z_V18,
- Z_V19,
- Z_V20,
- Z_V21,
- Z_V22,
- Z_V23,
- Z_V24,
- Z_V25,
- Z_V26,
- Z_V27,
- Z_V28,
- Z_V29,
- Z_V30,
- Z_V31
+  Z_CR
 );
 
 
@@ -609,22 +736,22 @@ reg_class z_dbl_reg(
 reg_class z_rscratch1_dbl_reg(Z_F1,Z_F1_H);
 
 reg_class z_v_reg(
- Z_V16,
- Z_V17,
- Z_V18,
- Z_V19,
- Z_V20,
- Z_V21,
- Z_V22,
- Z_V23,
- Z_V24,
- Z_V25,
- Z_V26,
- Z_V27,
- Z_V28,
- Z_V29,
- Z_V30,
- Z_V31
+ Z_VR16, Z_VR16_H, Z_VR16_J, Z_VR16_K,
+ Z_VR17, Z_VR17_H, Z_VR17_J, Z_VR17_K,
+ Z_VR18, Z_VR18_H, Z_VR18_J, Z_VR18_K,
+ Z_VR19, Z_VR19_H, Z_VR19_J, Z_VR19_K,
+ Z_VR20, Z_VR20_H, Z_VR20_J, Z_VR20_K,
+ Z_VR21, Z_VR21_H, Z_VR21_J, Z_VR21_K,
+ Z_VR22, Z_VR22_H, Z_VR22_J, Z_VR22_K,
+ Z_VR23, Z_VR23_H, Z_VR23_J, Z_VR23_K,
+ Z_VR24, Z_VR24_H, Z_VR24_J, Z_VR24_K,
+ Z_VR25, Z_VR25_H, Z_VR25_J, Z_VR25_K,
+ Z_VR26, Z_VR26_H, Z_VR26_J, Z_VR26_K,
+ Z_VR27, Z_VR27_H, Z_VR27_J, Z_VR27_K,
+ Z_VR28, Z_VR28_H, Z_VR28_J, Z_VR28_K,
+ Z_VR29, Z_VR29_H, Z_VR29_J, Z_VR29_K,
+ Z_VR30, Z_VR30_H, Z_VR30_J, Z_VR30_K,
+ Z_VR31, Z_VR31_H, Z_VR31_J, Z_VR31_K,
 );
 
 %}
@@ -10705,7 +10832,7 @@ instruct repl4I_immIminus1(vecX dst, immI_minus1 src) %{
   predicate(n->as_Vector()->length() == 4);
 
   format %{ "VNX      $dst, $dst, $dst \t// replicate4I" %}
-  size(4);
+  size(6);
   ins_encode %{
     __ z_vnx($dst$$VectorRegister, $dst$$VectorRegister, $dst$$VectorRegister);
   %}
diff --git a/src/hotspot/cpu/s390/vmreg_s390.cpp b/src/hotspot/cpu/s390/vmreg_s390.cpp
index 2938062be89..2240e27e19c 100644
--- a/src/hotspot/cpu/s390/vmreg_s390.cpp
+++ b/src/hotspot/cpu/s390/vmreg_s390.cpp
@@ -47,6 +47,7 @@ void VMRegImpl::set_regName() {
   VectorRegister vreg = ::as_VectorRegister(0);
   for (; i < ConcreteRegisterImpl::max_vr;) {
     regName[i++] = vreg->name();
+    vreg = vreg->successor();
   }
 
   for (; i < ConcreteRegisterImpl::number_of_registers; i ++) {
diff --git a/src/hotspot/cpu/s390/vmreg_s390.hpp b/src/hotspot/cpu/s390/vmreg_s390.hpp
index 595e7ba5557..9b6848a5b21 100644
--- a/src/hotspot/cpu/s390/vmreg_s390.hpp
+++ b/src/hotspot/cpu/s390/vmreg_s390.hpp
@@ -42,22 +42,33 @@ inline bool is_VectorRegister() {
 
 inline Register as_Register() {
   assert(is_Register() && is_even(value()), "even-aligned GPR name");
-  return ::as_Register(value() >> 1);
+  return ::as_Register(value() / Register::max_slots_per_register);
 }
 
 inline FloatRegister as_FloatRegister() {
   assert(is_FloatRegister() && is_even(value()), "must be");
-  return ::as_FloatRegister((value() - ConcreteRegisterImpl::max_gpr) >> 1);
+  return ::as_FloatRegister((value() - ConcreteRegisterImpl::max_gpr)
+			    / FloatRegister::max_slots_per_register);
 }
 
 inline VectorRegister as_VectorRegister() {
-  assert(is_VectorRegister() && is_even(value()), "must be");
-  return ::as_VectorRegister(value() - ConcreteRegisterImpl::max_fpr);
+  assert(is_VectorRegister()
+	 && (value() % VectorRegister::max_slots_per_register == 0), "must be");
+  return ::as_VectorRegister((value() - ConcreteRegisterImpl::max_fpr)
+			     / VectorRegister::max_slots_per_register);
 }
 
 inline bool is_concrete() {
   assert(is_reg(), "must be");
-  return is_even(value());
+  if (is_FloatRegister()) {
+    int base = value() - ConcreteRegisterImpl::max_gpr;
+    return (base % FloatRegister::max_slots_per_register) == 0;
+  } else if (is_VectorRegister()) {
+    int base = value() - ConcreteRegisterImpl::max_fpr;
+    return (base % VectorRegister::max_slots_per_register) == 0;
+  } else {
+    return is_even(value());
+  }
 }
 
 #endif // CPU_S390_VMREG_S390_HPP
diff --git a/src/hotspot/share/utilities/debug.hpp b/src/hotspot/share/utilities/debug.hpp
index 65051a24d7d..52a13699712 100644
--- a/src/hotspot/share/utilities/debug.hpp
+++ b/src/hotspot/share/utilities/debug.hpp
@@ -39,7 +39,7 @@ class oopDesc;
 #if defined(LINUX) && !defined(ZERO)
 #define CAN_SHOW_REGISTERS_ON_ASSERT
 extern char* g_assert_poison;
-#define TOUCH_ASSERT_POISON (*g_assert_poison) = 'X';
+#define TOUCH_ASSERT_POISON
 void initialize_assert_poison();
 void disarm_assert_poison();
 bool handle_assert_poison_fault(const void* ucVoid, const void* faulting_address);
