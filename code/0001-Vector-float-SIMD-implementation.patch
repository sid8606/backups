From 70f6325f4b6e4295d1f4c12bd0ecc46d0483f933 Mon Sep 17 00:00:00 2001
From: Sidraya <root@t83lp72.lnxero1.boe>
Date: Mon, 3 Apr 2023 07:25:42 +0000
Subject: [PATCH] Vector-float-SIMD-implementation.

---
 src/hotspot/cpu/s390/assembler_s390.hpp       |  13 ++
 .../cpu/s390/assembler_s390.inline.hpp        |   8 +
 src/hotspot/cpu/s390/globals_s390.hpp         |   3 +
 src/hotspot/cpu/s390/registerSaver_s390.hpp   |   2 +
 src/hotspot/cpu/s390/register_s390.cpp        |   4 +-
 src/hotspot/cpu/s390/register_s390.hpp        |   5 +-
 src/hotspot/cpu/s390/s390.ad                  | 173 +++++++++++++++++-
 src/hotspot/cpu/s390/sharedRuntime_s390.cpp   |   2 +-
 src/hotspot/cpu/s390/vm_version_s390.cpp      |   6 +-
 src/hotspot/cpu/s390/vmreg_s390.cpp           |   7 +
 src/hotspot/cpu/s390/vmreg_s390.hpp           |  10 +
 src/hotspot/cpu/s390/vmreg_s390.inline.hpp    |   7 +-
 src/hotspot/share/adlc/output_c.cpp           |   3 +
 src/hotspot/share/opto/machnode.hpp           |   8 +
 src/hotspot/share/opto/type.cpp               |   4 +-
 15 files changed, 243 insertions(+), 12 deletions(-)

diff --git a/src/hotspot/cpu/s390/assembler_s390.hpp b/src/hotspot/cpu/s390/assembler_s390.hpp
index a0a86a707dd..580fa70f4ce 100644
--- a/src/hotspot/cpu/s390/assembler_s390.hpp
+++ b/src/hotspot/cpu/s390/assembler_s390.hpp
@@ -1233,6 +1233,9 @@ class Assembler : public AbstractAssembler {
 // NOR
 #define VNO_ZOPC    (unsigned long)(0xe7L << 40 | 0x6bL << 0)   // V1 := !(V2 | V3),  element size = 2**m
 
+ //NOT-XOR
+#define VNX_ZOPC    (unsigned long)(0xe7L << 40 | 0x6cL << 0)   // V1 := !(V2 | V3),  element size = 2**m
+
 // OR
 #define VO_ZOPC     (unsigned long)(0xe7L << 40 | 0x6aL << 0)   // V1 := V2 | V3,  element size = 2**m
 
@@ -1284,6 +1287,8 @@ class Assembler : public AbstractAssembler {
 #define VSTRC_ZOPC  (unsigned long)(0xe7L << 40 | 0x8aL << 0)   // String range compare
 #define VISTR_ZOPC  (unsigned long)(0xe7L << 40 | 0x5cL << 0)   // Isolate String
 
+#define VFADB_ZOPC   (unsigned long)(0xe7L << 40 | 0xE3L << 0)   // Find any element
+
 
 //--------------------------------
 //--  Miscellaneous Operations  --
@@ -2472,6 +2477,8 @@ class Assembler : public AbstractAssembler {
   inline void z_vlef(  VectorRegister v1, int64_t d2, Register x2, Register b2, int64_t m3);
   inline void z_vleg(  VectorRegister v1, int64_t d2, Register x2, Register b2, int64_t m3);
 
+  inline void z_vl(VectorRegister v1, const Address& a);
+
   // Gather/Scatter
   inline void z_vgef(  VectorRegister v1, int64_t d2, VectorRegister vx2, Register b2, int64_t m3);
   inline void z_vgeg(  VectorRegister v1, int64_t d2, VectorRegister vx2, Register b2, int64_t m3);
@@ -2601,6 +2608,8 @@ class Assembler : public AbstractAssembler {
   inline void z_vsteg( VectorRegister v1, int64_t d2, Register x2, Register b2, int64_t m3);
   inline void z_vstl(  VectorRegister v1, Register r3, int64_t d2, Register b2);
 
+  inline void z_vst(VectorRegister v1, const Address& a);
+
   // Misc
   inline void z_vgm(   VectorRegister v1, int64_t imm2, int64_t imm3, int64_t m4);
   inline void z_vgmb(  VectorRegister v1, int64_t imm2, int64_t imm3);
@@ -2720,6 +2729,9 @@ class Assembler : public AbstractAssembler {
   // NOR
   inline void z_vno(    VectorRegister v1, VectorRegister v2, VectorRegister v3);
 
+  //NOT-XOR
+  inline void z_vnx(    VectorRegister v1, VectorRegister v2, VectorRegister v3);
+
   // OR
   inline void z_vo(     VectorRegister v1, VectorRegister v2, VectorRegister v3);
 
@@ -2873,6 +2885,7 @@ class Assembler : public AbstractAssembler {
   inline void z_vistrhs(VectorRegister v1, VectorRegister v2);
   inline void z_vistrfs(VectorRegister v1, VectorRegister v2);
 
+  inline void z_vfadb(VectorRegister v1, VectorRegister v2, VectorRegister v3, int64_t m4);   // Find any element
 
   // Floatingpoint instructions
   // ==========================
diff --git a/src/hotspot/cpu/s390/assembler_s390.inline.hpp b/src/hotspot/cpu/s390/assembler_s390.inline.hpp
index 2eb6cfb812c..739a58a2bb2 100644
--- a/src/hotspot/cpu/s390/assembler_s390.inline.hpp
+++ b/src/hotspot/cpu/s390/assembler_s390.inline.hpp
@@ -772,6 +772,7 @@ inline void Assembler::z_vleh(   VectorRegister v1, int64_t d2, Register x2, Reg
 inline void Assembler::z_vlef(   VectorRegister v1, int64_t d2, Register x2, Register b2, int64_t ix3){emit_48(VLEF_ZOPC  | vreg(v1,  8)                        | rxmask_48(d2, x2, b2) | uimm4(ix3, 32, 48)); }
 inline void Assembler::z_vleg(   VectorRegister v1, int64_t d2, Register x2, Register b2, int64_t ix3){emit_48(VLEG_ZOPC  | vreg(v1,  8)                        | rxmask_48(d2, x2, b2) | uimm4(ix3, 32, 48)); }
 
+inline void Assembler::z_vl(VectorRegister v1, const Address& a)  { z_vl(v1, a.disp(), a.indexOrR0(), a.baseOrR0()); }
 
 // Gather/Scatter
 inline void Assembler::z_vgef(   VectorRegister v1, int64_t d2, VectorRegister vx2, Register b2, int64_t ix3) {emit_48(VGEF_ZOPC  | vreg(v1,  8)                | rvmask_48(d2, vx2, b2) | uimm4(ix3, 32, 48)); }
@@ -902,6 +903,8 @@ inline void Assembler::z_vstef(  VectorRegister v1, int64_t d2, Register x2, Reg
 inline void Assembler::z_vsteg(  VectorRegister v1, int64_t d2, Register x2, Register b2, int64_t ix3){emit_48(VSTEG_ZOPC | vreg(v1,  8)                        | rxmask_48(d2, x2, b2) | uimm4(ix3, 32, 48)); }
 inline void Assembler::z_vstl(   VectorRegister v1, Register r3, int64_t d2, Register b2)             {emit_48(VSTL_ZOPC  | vreg(v1,  8)     |  reg(r3, 12, 48) | rsmask_48(d2,     b2)); }
 
+inline void Assembler::z_vst(VectorRegister v1, const Address& a)  { z_vl(v1, a.disp(), a.indexOrR0(), a.baseOrR0()); }
+
 // Misc
 inline void Assembler::z_vgm(    VectorRegister v1, int64_t imm2, int64_t imm3, int64_t m4)           {emit_48(VGM_ZOPC   | vreg(v1,  8)     | uimm8( imm2, 16, 48) | uimm8(imm3, 24, 48) | vesc_mask(m4, VRET_BYTE, VRET_DW, 32)); }
 inline void Assembler::z_vgmb(   VectorRegister v1, int64_t imm2, int64_t imm3)                       {z_vgm(v1, imm2, imm3, VRET_BYTE); } // vector element type 'B'
@@ -1020,6 +1023,9 @@ inline void Assembler::z_vx(     VectorRegister v1, VectorRegister v2, VectorReg
 // NOR
 inline void Assembler::z_vno(    VectorRegister v1, VectorRegister v2, VectorRegister v3)             {emit_48(VNO_ZOPC   | vreg(v1,  8) | vreg(v2, 12) | vreg(v3, 16)); }
 
+//NOT-XOR
+inline void Assembler::z_vnx(    VectorRegister v1, VectorRegister v2, VectorRegister v3)             {emit_48(VNX_ZOPC   | vreg(v1,  8) | vreg(v2, 12) | vreg(v3, 16)); }
+
 // OR
 inline void Assembler::z_vo(     VectorRegister v1, VectorRegister v2, VectorRegister v3)             {emit_48(VO_ZOPC    | vreg(v1,  8) | vreg(v2, 12) | vreg(v3, 16)); }
 
@@ -1173,6 +1179,8 @@ inline void Assembler::z_vistrbs(VectorRegister v1, VectorRegister v2)
 inline void Assembler::z_vistrhs(VectorRegister v1, VectorRegister v2)                            {z_vistr(v1, v2, VRET_HW,   VOPRC_CCSET); }
 inline void Assembler::z_vistrfs(VectorRegister v1, VectorRegister v2)                            {z_vistr(v1, v2, VRET_FW,   VOPRC_CCSET); }
 
+inline void Assembler::z_vfadb(  VectorRegister v1, VectorRegister v2, VectorRegister v3, int64_t m4)        {emit_48(VFADB_ZOPC | vreg(v1,  8) | vreg(v2, 12) | vreg(v3, 16) | vesc_mask(0, VRET_BYTE, VRET_DW, 28) | vesc_mask(m4, VRET_BYTE, VRET_DW, 32)); }
+
 
 //-------------------------------
 // FLOAT INSTRUCTIONS
diff --git a/src/hotspot/cpu/s390/globals_s390.hpp b/src/hotspot/cpu/s390/globals_s390.hpp
index 24f0af92c37..5b7a93b9cba 100644
--- a/src/hotspot/cpu/s390/globals_s390.hpp
+++ b/src/hotspot/cpu/s390/globals_s390.hpp
@@ -106,6 +106,9 @@ define_pd_global(intx, InitArrayShortSize, 1*BytesPerLong);
   /* Seems to pay off with 2 pages already. */                                \
   product(size_t, MVCLEThreshold, +2*(4*K), DIAGNOSTIC,                       \
           "Threshold above which page-aligned MVCLE copy/init is used.")      \
+  /* special instructions */                                                  \
+  product(bool, SuperwordUseVSX, false,                                       \
+          "Use Z15 Vector instructions for superword optimization.")          \
                                                                               \
   product(bool, PreferLAoverADD, false, DIAGNOSTIC,                           \
           "Use LA/LAY instructions over ADD instructions (z/Architecture).")  \
diff --git a/src/hotspot/cpu/s390/registerSaver_s390.hpp b/src/hotspot/cpu/s390/registerSaver_s390.hpp
index 97883685384..8f87f3f4d92 100644
--- a/src/hotspot/cpu/s390/registerSaver_s390.hpp
+++ b/src/hotspot/cpu/s390/registerSaver_s390.hpp
@@ -65,11 +65,13 @@ class RegisterSaver {
     int_reg           = 0,
     float_reg         = 1,
     excluded_reg      = 2,  // Not saved/restored.
+    vs_reg	      = 3,
   } RegisterType;
 
   typedef enum {
     reg_size          = 8,
     half_reg_size     = reg_size / 2,
+    vs_reg_size       = 16,
   } RegisterConstants;
 
   // Remember type, number, and VMReg.
diff --git a/src/hotspot/cpu/s390/register_s390.cpp b/src/hotspot/cpu/s390/register_s390.cpp
index 853b5642470..242beca59a2 100644
--- a/src/hotspot/cpu/s390/register_s390.cpp
+++ b/src/hotspot/cpu/s390/register_s390.cpp
@@ -26,11 +26,11 @@
 #include "precompiled.hpp"
 #include "register_s390.hpp"
 
-
 const int ConcreteRegisterImpl::max_gpr = RegisterImpl::number_of_registers * 2;
 const int ConcreteRegisterImpl::max_fpr = ConcreteRegisterImpl::max_gpr +
                                           FloatRegisterImpl::number_of_registers * 2;
-
+const int ConcreteRegisterImpl::max_vr = ConcreteRegisterImpl::max_fpr +
+					  VectorRegisterImpl::number_of_registers;
 const char* RegisterImpl::name() const {
   const char* names[number_of_registers] = {
     "Z_R0",  "Z_R1",  "Z_R2",  "Z_R3",  "Z_R4",  "Z_R5",  "Z_R6",  "Z_R7",
diff --git a/src/hotspot/cpu/s390/register_s390.hpp b/src/hotspot/cpu/s390/register_s390.hpp
index 59da743016f..1b532d4ca40 100644
--- a/src/hotspot/cpu/s390/register_s390.hpp
+++ b/src/hotspot/cpu/s390/register_s390.hpp
@@ -477,10 +477,13 @@ class ConcreteRegisterImpl : public AbstractRegisterImpl {
       (RegisterImpl::number_of_registers +
       FloatRegisterImpl::number_of_registers)
       * 2 // register halves
-      + 1 // condition code register
+      + VectorRegisterImpl::number_of_registers
+      + 1 // condition code register        
   };
+
   static const int max_gpr;
   static const int max_fpr;
+  static const int max_vr;
 };
 
 
diff --git a/src/hotspot/cpu/s390/s390.ad b/src/hotspot/cpu/s390/s390.ad
index 1e54b26a554..c06193030a8 100644
--- a/src/hotspot/cpu/s390/s390.ad
+++ b/src/hotspot/cpu/s390/s390.ad
@@ -194,6 +194,38 @@ register %{
 
   reg_def Z_CR(SOC, SOC, Op_RegFlags, 0, Z_CR->as_VMReg());   // volatile
 
+  reg_def Z_V0 ( SOC, SOC, Op_VecX, 0, VMRegImpl::Bad());
+  reg_def Z_V1 ( SOC, SOC, Op_VecX, 1, VMRegImpl::Bad());
+  reg_def Z_V2 ( SOC, SOC, Op_VecX, 2, VMRegImpl::Bad());
+  reg_def Z_V3 ( SOC, SOC, Op_VecX, 3, VMRegImpl::Bad());
+  reg_def Z_V4 ( SOC, SOC, Op_VecX, 4, VMRegImpl::Bad());
+  reg_def Z_V5 ( SOC, SOC, Op_VecX, 5, VMRegImpl::Bad());
+  reg_def Z_V6 ( SOC, SOC, Op_VecX, 6, VMRegImpl::Bad());
+  reg_def Z_V7 ( SOC, SOC, Op_VecX, 7, VMRegImpl::Bad());
+  reg_def Z_V8 ( SOC, SOC, Op_VecX, 8, VMRegImpl::Bad());
+  reg_def Z_V9 ( SOC, SOC, Op_VecX, 9, VMRegImpl::Bad());
+  reg_def Z_V10 ( SOC, SOC, Op_VecX, 10, VMRegImpl::Bad());
+  reg_def Z_V11 ( SOC, SOC, Op_VecX, 11, VMRegImpl::Bad());
+  reg_def Z_V12 ( SOC, SOC, Op_VecX, 12, VMRegImpl::Bad());
+  reg_def Z_V13 ( SOC, SOC, Op_VecX, 13, VMRegImpl::Bad());
+  reg_def Z_V14 ( SOC, SOC, Op_VecX, 14, VMRegImpl::Bad());
+  reg_def Z_V15 ( SOC, SOC, Op_VecX, 15, VMRegImpl::Bad());
+  reg_def Z_V16 ( SOC, SOC, Op_VecX, 16, Z_V16->as_VMReg());
+  reg_def Z_V17 ( SOC, SOC, Op_VecX, 17, Z_V17->as_VMReg());
+  reg_def Z_V18 ( SOC, SOC, Op_VecX, 18, Z_V18->as_VMReg());
+  reg_def Z_V19 ( SOC, SOC, Op_VecX, 19, Z_V19->as_VMReg());
+  reg_def Z_V20 ( SOC, SOC, Op_VecX, 20, Z_V20->as_VMReg());
+  reg_def Z_V21 ( SOC, SOC, Op_VecX, 21, Z_V21->as_VMReg());
+  reg_def Z_V22 ( SOC, SOC, Op_VecX, 22, Z_V22->as_VMReg());
+  reg_def Z_V23 ( SOC, SOC, Op_VecX, 23, Z_V23->as_VMReg());
+  reg_def Z_V24 ( SOC, SOC, Op_VecX, 24, Z_V24->as_VMReg());
+  reg_def Z_V25 ( SOC, SOC, Op_VecX, 25, Z_V25->as_VMReg());
+  reg_def Z_V26 ( SOC, SOC, Op_VecX, 26, Z_V26->as_VMReg());
+  reg_def Z_V27 ( SOC, SOC, Op_VecX, 27, Z_V27->as_VMReg());
+  reg_def Z_V28 ( SOC, SOC, Op_VecX, 28, Z_V28->as_VMReg());
+  reg_def Z_V29 ( SOC, SOC, Op_VecX, 29, Z_V29->as_VMReg());
+  reg_def Z_V30 ( SOC, SOC, Op_VecX, 30, Z_V30->as_VMReg());
+  reg_def Z_V31 ( SOC, SOC, Op_VecX, 31, Z_V31->as_VMReg());
 
 // Specify priority of register selection within phases of register
 // allocation. Highest priority is first. A useful heuristic is to
@@ -271,6 +303,41 @@ alloc_class chunk2(
   Z_CR
 );
 
+alloc_class chunk3(
+ Z_V0,
+ Z_V1,
+ Z_V2,
+ Z_V3,
+ Z_V4,
+ Z_V5,
+ Z_V6,
+ Z_V7,
+ Z_V8,
+ Z_V9,
+ Z_V10,
+ Z_V11,
+ Z_V12,
+ Z_V13,
+ Z_V14,
+ Z_V15,
+ Z_V16,
+ Z_V17,
+ Z_V18,
+ Z_V19,
+ Z_V20,
+ Z_V21,
+ Z_V22,
+ Z_V23,
+ Z_V24,
+ Z_V25,
+ Z_V26,
+ Z_V27,
+ Z_V28,
+ Z_V29,
+ Z_V30,
+ Z_V31
+);
+
 
 //-------Architecture Description Register Classes-----------------------
 
@@ -540,6 +607,26 @@ reg_class z_dbl_reg(
 );
 reg_class z_rscratch1_dbl_reg(Z_F1,Z_F1_H);
 
+reg_class z_v_reg(
+ Z_V16,
+ Z_V17,
+ Z_V18,
+ Z_V19,
+ Z_V20,
+ Z_V21,
+ Z_V22,
+ Z_V23,
+ Z_V24,
+ Z_V25,
+ Z_V26,
+ Z_V27,
+ Z_V28,
+ Z_V29,
+ Z_V30,
+ Z_V31
+);
+
+
 %}
 
 //----------DEFINITION BLOCK---------------------------------------------------
@@ -1513,6 +1600,8 @@ const bool Matcher::match_rule_supported(int opcode) {
     case Op_PopCountL:
       // PopCount supported by H/W from z/Architecture G5 (z196) on.
       return (UsePopCountInstruction && VM_Version::has_PopCount());
+    case Op_AddVD:
+	return SuperwordUseVSX;
   }
 
   return true; // Per default match rules are supported.
@@ -1559,14 +1648,25 @@ OptoRegPair Matcher::vector_return_value(uint ideal_reg) {
 
 // Vector width in bytes.
 const int Matcher::vector_width_in_bytes(BasicType bt) {
-  assert(MaxVectorSize == 8, "");
-  return 8;
+  if (SuperwordUseVSX) {
+    assert(MaxVectorSize == 16, "");
+    return 16;
+  } else {
+    assert(MaxVectorSize == 8, "");
+    return 8;
+  }
+
 }
 
 // Vector ideal reg.
 const uint Matcher::vector_ideal_reg(int size) {
-  assert(MaxVectorSize == 8 && size == 8, "");
-  return Op_RegL;
+  if (SuperwordUseVSX) {
+    assert(MaxVectorSize == 16 && size == 16, "");
+    return Op_VecX;
+  } else {
+    assert(MaxVectorSize == 8 && size == 8, "");
+    return Op_RegL;
+  }
 }
 
 // Limits on vector size (number of elements) loaded into vector.
@@ -2465,6 +2565,14 @@ ins_attrib ins_should_rematerialize(false);
 // parsing in the ADLC because operands constitute user defined types
 // which are used in instruction definitions.
 
+operand vecX() %{
+  constraint(ALLOC_IN_RC(z_v_reg));
+  match(VecX);
+
+  format %{ %}
+  interface(REG_INTER);
+%}
+
 //----------Simple Operands----------------------------------------------------
 // Immediate Operands
 // Please note:
@@ -10596,6 +10704,17 @@ instruct Repl2I_immm1(iRegL dst, immI_minus1 src) %{
 %}
 
 //
+instruct repl4I_immIminus1(vecX dst, immI_minus1 src) %{
+  match(Set dst (ReplicateI src));
+  predicate(n->as_Vector()->length() == 4);
+
+  format %{ "VNX      $dst, $dst, $dst \t// replicate4I" %}
+  size(4);
+  ins_encode %{
+    __ z_vnx($dst$$VectorRegister, $dst$$VectorRegister, $dst$$VectorRegister);
+  %}
+  ins_pipe(pipe_class_dummy);
+%}
 
 instruct Repl2F_reg_indirect(iRegL dst, regF src, flagsReg cr) %{
   match(Set dst (ReplicateF src));
@@ -10671,6 +10790,22 @@ instruct storeA8B(memory mem, iRegL src) %{
   ins_pipe(pipe_class_dummy);
 %}
 
+// Store Packed Byte long register to memory
+instruct storeV16(memoryRX mem, vecX src) %{
+  predicate(n->as_StoreVector()->memory_size() == 16);
+  match(Set mem (StoreVector mem src));
+  ins_cost(MEMORY_REF_COST);
+
+  format %{ "VST  $mem, $src \t// store 16-byte Vector" %}
+  size(6);
+  ins_encode %{
+    __ z_vst($src$$VectorRegister,
+              Address(reg_to_register_object($mem$$base), $mem$$index$$Register, $mem$$disp));
+
+  %}
+  ins_pipe(pipe_class_dummy);
+%}
+
 instruct loadV8(iRegL dst, memory mem) %{
   match(Set dst (LoadVector mem));
   predicate(n->as_LoadVector()->memory_size() == 8);
@@ -10682,6 +10817,21 @@ instruct loadV8(iRegL dst, memory mem) %{
   ins_pipe(pipe_class_dummy);
 %}
 
+// Load Aligned Packed Byte
+instruct loadV16(vecX dst, memoryRX mem) %{
+  predicate(n->as_LoadVector()->memory_size() == 16);
+  match(Set dst (LoadVector mem));
+  ins_cost(MEMORY_REF_COST);
+
+  format %{ "VL  $dst, $mem \t// load 16-byte Vector" %}
+  size(6);
+  ins_encode %{
+     __ z_vl($dst$$VectorRegister,
+              Address(reg_to_register_object($mem$$base), $mem$$index$$Register, $mem$$disp));
+  %}
+  ins_pipe(pipe_class_dummy);
+%}
+
 // Reinterpret: only one vector size used
 instruct reinterpret(iRegL dst) %{
   match(Set dst (VectorReinterpret dst));
@@ -10691,6 +10841,21 @@ instruct reinterpret(iRegL dst) %{
   ins_pipe(pipe_class_dummy);
 %}
 
+//----------Vector Arithmetic Instructions--------------------------------------
+
+// Vector Addition Instructions
+
+instruct vadd2D_reg(vecX dst, vecX src1, vecX src2) %{
+  match(Set dst (AddVD src1 src2));
+  predicate(n->as_Vector()->length() == 2);
+  format %{ "VFADB  $dst,$src1,$src2\t// add packed2D" %}
+  size(6);
+  ins_encode %{
+    __ z_vfadb($dst$$VectorRegister, $src1$$VectorRegister, $src2$$VectorRegister, 3);
+  %}
+  ins_pipe(pipe_class_dummy);
+%}
+
 //----------POPULATION COUNT RULES--------------------------------------------
 
 // Byte reverse
diff --git a/src/hotspot/cpu/s390/sharedRuntime_s390.cpp b/src/hotspot/cpu/s390/sharedRuntime_s390.cpp
index c3158e8e8ce..4ec8b889b07 100644
--- a/src/hotspot/cpu/s390/sharedRuntime_s390.cpp
+++ b/src/hotspot/cpu/s390/sharedRuntime_s390.cpp
@@ -983,7 +983,7 @@ static void gen_special_dispatch(MacroAssembler *masm,
 // 8 bytes registers are saved by default on z/Architecture.
 bool SharedRuntime::is_wide_vector(int size) {
   // Note, MaxVectorSize == 8 on this platform.
-  assert(size <= 8, "%d bytes vectors are not supported", size);
+  assert(size <= 16, "%d bytes vectors are not supported", size);
   return size > 8;
 }
 
diff --git a/src/hotspot/cpu/s390/vm_version_s390.cpp b/src/hotspot/cpu/s390/vm_version_s390.cpp
index e53d6fc5635..1c0a795ea12 100644
--- a/src/hotspot/cpu/s390/vm_version_s390.cpp
+++ b/src/hotspot/cpu/s390/vm_version_s390.cpp
@@ -97,7 +97,11 @@ void VM_Version::initialize() {
   intx cache_line_size = Dcache_lineSize(0);
 
 #ifdef COMPILER2
-  MaxVectorSize = 8;
+  if (FLAG_IS_DEFAULT(SuperwordUseVSX)) {
+      FLAG_SET_ERGO(SuperwordUseVSX, true);
+  }
+
+  MaxVectorSize = 16;
 #endif
 
   if (has_PrefetchRaw()) {
diff --git a/src/hotspot/cpu/s390/vmreg_s390.cpp b/src/hotspot/cpu/s390/vmreg_s390.cpp
index 239b68513b9..c088587006f 100644
--- a/src/hotspot/cpu/s390/vmreg_s390.cpp
+++ b/src/hotspot/cpu/s390/vmreg_s390.cpp
@@ -43,7 +43,14 @@ void VMRegImpl::set_regName() {
     regName[i++] = freg->name();
     freg = freg->successor();
   }
+
+  VectorRegister vreg = ::as_VectorRegister(0);
+  for (; i < ConcreteRegisterImpl::max_vr;) {
+    regName[i++] = vreg->name();
+  }
+
   for (; i < ConcreteRegisterImpl::number_of_registers; i ++) {
     regName[i] = "NON-GPR-XMM";
   }
+
 }
diff --git a/src/hotspot/cpu/s390/vmreg_s390.hpp b/src/hotspot/cpu/s390/vmreg_s390.hpp
index 3dd1bd9a16c..820fff3095c 100644
--- a/src/hotspot/cpu/s390/vmreg_s390.hpp
+++ b/src/hotspot/cpu/s390/vmreg_s390.hpp
@@ -35,6 +35,11 @@ inline bool is_FloatRegister() {
          value() < ConcreteRegisterImpl::max_fpr;
 }
 
+inline bool is_VectorRegister() {
+  return value() >= ConcreteRegisterImpl::max_fpr &&
+         value() < ConcreteRegisterImpl::max_vr;
+}
+
 inline Register as_Register() {
   assert(is_Register() && is_even(value()), "even-aligned GPR name");
   return ::as_Register(value() >> 1);
@@ -45,6 +50,11 @@ inline FloatRegister as_FloatRegister() {
   return ::as_FloatRegister((value() - ConcreteRegisterImpl::max_gpr) >> 1);
 }
 
+inline VectorRegister as_VectorRegister() {
+  assert(is_VectorRegister() && is_even(value()), "must be");
+  return ::as_VectorRegister((value() - ConcreteRegisterImpl::max_fpr) >> 1);
+}
+
 inline bool is_concrete() {
   assert(is_reg(), "must be");
   return is_even(value());
diff --git a/src/hotspot/cpu/s390/vmreg_s390.inline.hpp b/src/hotspot/cpu/s390/vmreg_s390.inline.hpp
index a775c8f971a..c156cae2d4e 100644
--- a/src/hotspot/cpu/s390/vmreg_s390.inline.hpp
+++ b/src/hotspot/cpu/s390/vmreg_s390.inline.hpp
@@ -37,8 +37,13 @@ inline VMReg FloatRegisterImpl::as_VMReg() {
   return VMRegImpl::as_VMReg((encoding() << 1) + ConcreteRegisterImpl::max_gpr);
 }
 
-inline VMReg ConditionRegisterImpl::as_VMReg() {
+inline VMReg VectorRegisterImpl::as_VMReg() {
   return VMRegImpl::as_VMReg((encoding() << 1) + ConcreteRegisterImpl::max_fpr);
 }
 
+inline VMReg ConditionRegisterImpl::as_VMReg() {
+  return VMRegImpl::as_VMReg((encoding() << 1) + ConcreteRegisterImpl::max_vr);
+}
+
+
 #endif // CPU_S390_VMREG_S390_INLINE_HPP
diff --git a/src/hotspot/share/adlc/output_c.cpp b/src/hotspot/share/adlc/output_c.cpp
index 93b32b73cbd..1e1eb9bc50c 100644
--- a/src/hotspot/share/adlc/output_c.cpp
+++ b/src/hotspot/share/adlc/output_c.cpp
@@ -2332,6 +2332,9 @@ private:
     if (strcmp(rep_var,"$VectorRegister") == 0)   return "as_VectorRegister";
     if (strcmp(rep_var,"$VectorSRegister") == 0)  return "as_VectorSRegister";
 #endif
+#if defined(S390)
+    if (strcmp(rep_var,"$VectorRegister") == 0)   return "as_VectorRegister";
+#endif     
 #if defined(AARCH64)
     if (strcmp(rep_var,"$PRegister") == 0)  return "as_PRegister";
 #endif
diff --git a/src/hotspot/share/opto/machnode.hpp b/src/hotspot/share/opto/machnode.hpp
index 921cf158ee9..2fac8c1d8a4 100644
--- a/src/hotspot/share/opto/machnode.hpp
+++ b/src/hotspot/share/opto/machnode.hpp
@@ -135,6 +135,14 @@ public:
     return ::as_VectorSRegister(reg(ra_, node, idx));
   }
 #endif
+#if defined(S390)
+  VectorRegister as_VectorRegister(PhaseRegAlloc *ra_, const Node *node) const {
+    return ::as_VectorRegister(reg(ra_, node));	  
+  }
+  VectorRegister as_VectorRegister(PhaseRegAlloc *ra_, const Node *node, int idx) const {
+    return ::as_VectorRegister(reg(ra_, node, idx));
+ }
+#endif 
 #if defined(AARCH64)
   PRegister as_PRegister(PhaseRegAlloc* ra_, const Node* node) const {
     return ::as_PRegister(reg(ra_, node));
diff --git a/src/hotspot/share/opto/type.cpp b/src/hotspot/share/opto/type.cpp
index 0534544bf0f..44fa92d1698 100644
--- a/src/hotspot/share/opto/type.cpp
+++ b/src/hotspot/share/opto/type.cpp
@@ -75,7 +75,7 @@ const Type::TypeInfo Type::_type_info[Type::lastype] = {
   { Bad,             T_ILLEGAL,    "vectora:",      false, Op_VecA,              relocInfo::none          },  // VectorA.
   { Bad,             T_ILLEGAL,    "vectors:",      false, 0,                    relocInfo::none          },  // VectorS
   { Bad,             T_ILLEGAL,    "vectord:",      false, Op_RegL,              relocInfo::none          },  // VectorD
-  { Bad,             T_ILLEGAL,    "vectorx:",      false, 0,                    relocInfo::none          },  // VectorX
+  { Bad,             T_ILLEGAL,    "vectorx:",      false, Op_VecX,              relocInfo::none          },  // VectorX
   { Bad,             T_ILLEGAL,    "vectory:",      false, 0,                    relocInfo::none          },  // VectorY
   { Bad,             T_ILLEGAL,    "vectorz:",      false, 0,                    relocInfo::none          },  // VectorZ
 #else // all other
@@ -1123,7 +1123,7 @@ bool Type::has_memory() const {
 #ifndef PRODUCT
 //------------------------------dump2------------------------------------------
 void Type::dump2( Dict &d, uint depth, outputStream *st ) const {
-  st->print("%s", _type_info[_base].msg);
+  st->print("sid:wow%s", _type_info[_base].msg);
 }
 
 //------------------------------dump-------------------------------------------
-- 
2.34.1

